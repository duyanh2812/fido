<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Login Success - FIDO Authentication</title>
    <link rel="stylesheet" href="/css/style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <div class="container">
        <header class="header">
            <h1><i class="fas fa-check-circle text-success"></i> Login Success!</h1>
            <p>Biometric authentication completed successfully</p>
        </header>

        <div class="main-content">
            <!-- Success Card -->
            <div class="card success-card">
                <div class="card-header">
                    <h2><i class="fas fa-shield-alt"></i> Authentication Successful</h2>
                </div>
                <div class="card-body">
                    <div class="success-message">
                        <i class="fas fa-fingerprint fa-3x text-success"></i>
                        <h3 id="success-title">🎉 Passkey Login Successful!</h3>
                        <p id="success-description">You have successfully authenticated using your biometric credentials.</p>
                    </div>


                    <!-- User Information -->
                    <div class="user-info" id="user-info" style="display: none;">
                        <h4><i class="fas fa-user"></i> User Information</h4>
                        <div class="user-details">
                            <div class="user-field">
                                <label>Username:</label>
                                <span id="username" class="user-value"></span>
                            </div>
                            <div class="user-field">
                                <label>Organization:</label>
                                <span id="org-name" class="user-value"></span>
                            </div>
                        </div>
                    </div>

                    <!-- FIDO Registration Section -->
                    <div class="fido-section" id="fido-section">
                        <h4><i class="fas fa-fingerprint"></i> FIDO Passkey Management</h4>
                        <div class="fido-info">
                            <p>Manage your biometric credentials for secure authentication.</p>
                            <div class="button-group">
                                <button onclick="startFidoRegistration()" class="btn btn-success" id="fido-register-btn">
                                    <i class="fas fa-plus"></i> Register FIDO Credential
                                </button>
                                <button onclick="deregisterFidoCredential()" class="btn btn-danger" id="fido-deregister-btn" style="display: none;">
                                    <i class="fas fa-trash"></i> Deregister FIDO Credential
                                </button>
                                <button onclick="startBiometricAuth()" class="btn btn-warning" id="biometric-auth-btn" style="display: none;">
                                    <i class="fas fa-fingerprint"></i> Biometric Authenticate
                                </button>
                            </div>
                            <div id="fido-status-message" class="status-message"></div>
                        </div>
                    </div>

                    <!-- Action Buttons -->
                    <div class="action-buttons">
                        <button onclick="logoutSuccess()" class="btn btn-danger">
                            <i class="fas fa-sign-out-alt"></i> Logout
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const WSO2_CLIENT_ID = 'jDsWosgzDKXGRUPHXhLnlm1wQQ8a';
        
        // Helper functions from app.js
        function makeRequest(url, options = {}) {
            return fetch(url, options)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response.json();
                });
        }

        function showMessage(elementId, message, type) {
            const element = document.getElementById(elementId);
            if (element) {
                element.textContent = message;
                element.className = `status-message ${type}`;
                element.style.display = 'block';
            }
        }

        function hideMessage(elementId) {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'none';
            }
        }

        function showLoading(message = 'Loading...') {
            // Simple loading implementation
            console.log('Loading:', message);
        }

        function hideLoading() {
            console.log('Loading complete');
        }

        // FIDO Registration function
        async function startFidoRegistration() {
            try {
                showLoading('Starting FIDO registration...');
                hideMessage('fido-status-message');

                // Get user info from JWT token
                const accessToken = localStorage.getItem('accessToken');
                let username = 'admin'; // Default fallback
                let displayName = 'Admin User'; // Default fallback
                
                if (accessToken) {
                    try {
                        const tokenParts = accessToken.split('.');
                        if (tokenParts.length === 3) {
                            const payload = JSON.parse(atob(tokenParts[1]));
                            username = payload.sub || 'admin';
                            displayName = payload.name || payload.sub || 'Admin User';
                        }
                    } catch (error) {
                        console.warn('Could not decode JWT token, using defaults:', error);
                    }
                }

                // Get registration options from backend
                const response = await makeRequest('/fido/registration-options', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + accessToken
                    },
                    body: JSON.stringify({
                        username: username,
                        displayName: displayName
                    })
                });

                if (!response.success) {
                    throw new Error(response.message || 'Failed to get registration options');
                }

                const options = response.data;
                console.log('Registration options:', options);
                console.log('🔍 Challenge data:', options.publicKeyCredentialCreationOptions.challenge);
                console.log('🔍 Challenge type:', typeof options.publicKeyCredentialCreationOptions.challenge);

                // Convert challenge to ArrayBuffer
                let challenge;
                const challengeData = options.publicKeyCredentialCreationOptions.challenge;
                
                if (typeof challengeData === 'string') {
                    // If it's a string, try to convert from base64/base64url
                    challenge = base64ToArrayBuffer(challengeData);
                } else if (challengeData instanceof Uint8Array) {
                    // If it's already a Uint8Array, convert to ArrayBuffer
                    challenge = challengeData.buffer;
                } else if (challengeData instanceof ArrayBuffer) {
                    // If it's already an ArrayBuffer, use it directly
                    challenge = challengeData;
                } else {
                    throw new Error(`Unsupported challenge data type: ${typeof challengeData}`);
                }
                
                // Create credential
                const credential = await navigator.credentials.create({
                    publicKey: {
                        ...options.publicKeyCredentialCreationOptions,
                        challenge: challenge,
                        user: {
                            ...options.publicKeyCredentialCreationOptions.user,
                            id: (() => {
                                const userId = options.publicKeyCredentialCreationOptions.user.id;
                                if (typeof userId === 'string') {
                                    return base64ToArrayBuffer(userId);
                                } else if (userId instanceof Uint8Array) {
                                    return userId.buffer;
                                } else if (userId instanceof ArrayBuffer) {
                                    return userId;
                                } else {
                                    throw new Error(`Unsupported user ID type: ${typeof userId}`);
                                }
                            })()
                        }
                    }
                });

                console.log('Credential created:', credential);

                // Convert credential to base64url format
                const clientDataJSON = base64ToBase64Url(arrayBufferToBase64(credential.response.clientDataJSON));
                const attestationObject = base64ToBase64Url(arrayBufferToBase64(credential.response.attestationObject));

                // Register credential with backend
                const registerResponse = await makeRequest('/fido/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + localStorage.getItem('accessToken')
                    },
                    body: JSON.stringify({
                        username: username,
                        displayName: displayName,
                        requestId: options.requestId,
                        rawId: base64ToBase64Url(arrayBufferToBase64(credential.rawId)),
                        clientDataJSON: clientDataJSON,
                        attestationObject: attestationObject
                    })
                });

                if (!registerResponse.success) {
                    throw new Error(registerResponse.message || 'Failed to register credential');
                }

                // Store credential ID (per username from registration options)
                const credentialId = base64ToBase64Url(arrayBufferToBase64(credential.rawId));
                
                // Get userId from access token for credential storage
                let userId = 'admin'; // fallback
                
                try {
                    const accessToken = localStorage.getItem('accessToken');
                    if (accessToken) {
                        const payload = accessToken.split('.')[1];
                        const decodedPayload = JSON.parse(atob(payload));
                        console.log('🔍 Access Token payload for userId extraction in registration:', decodedPayload);
                        
                        // Extract userId from access token
                        userId = decodedPayload.sub || decodedPayload.user_id || decodedPayload.userId;
                        if (userId) {
                            console.log('🔍 Using userId from Access Token for registration:', userId);
                        } else {
                            console.warn('No userId found in access token for registration, using fallback');
                        }
                    }
                } catch (e) {
                    console.warn('Could not extract userId from access token for registration:', e);
                }
                
                // Store single credentialId
                localStorage.setItem('credentialId', credentialId);
                window.registeredCredentialId = credentialId;
                console.log(`🔍 Stored single credentialId: ${credentialId}`);

                showMessage('fido-status-message', '🎉 FIDO credential registered successfully!', 'success');
                hideLoading();

                // Update button visibility
                initializeFidoSection();

            } catch (error) {
                console.error('FIDO registration failed:', error);
                showMessage('fido-status-message', `Registration failed: ${error.message}`, 'error');
                hideLoading();
            }
        }

        // FIDO Deregistration function
        async function deregisterFidoCredential() {
            // Get the single credential ID from localStorage
            const credentialId = localStorage.getItem('credentialId');
            console.log('🔍 Looking for single credentialId:', credentialId);
            
            if (!credentialId) {
                showMessage('fido-status-message', 'No FIDO credential registered. Please register a passkey first.', 'error');
                return;
            }

            if (!confirm('Are you sure you want to deregister your FIDO credential? This action cannot be undone.')) {
                return;
            }

            try {
                showLoading('Deregistering FIDO credential...');
                hideMessage('fido-status-message');

                console.log(`🔍 Deregistering credential ID: ${credentialId}`);

                const response = await makeRequest(`/fido/deregister/${credentialId}`, {
                    method: 'DELETE',
                    headers: {
                        'Authorization': 'Bearer ' + localStorage.getItem('accessToken')
                    }
                });

                if (!response.success) {
                    throw new Error(response.message || 'Failed to deregister credential');
                }

                // Clear stored credential ID
                console.log(`🔍 Deregister: Clearing single credentialId`);
                localStorage.removeItem('credentialId');
                window.registeredCredentialId = null;

                showMessage('fido-status-message', 'FIDO credential deregistered successfully!', 'success');
                hideLoading();

                // Update button visibility
                initializeFidoSection();

            } catch (error) {
                console.error('FIDO deregistration failed:', error);
                showMessage('fido-status-message', `Deregistration failed: ${error.message}`, 'error');
                hideLoading();
            }
        }

        // Helper functions for base64 conversion
        function base64urlToBase64(base64url) {
            // Convert base64url to base64
            let base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            // Add padding if needed
            while (base64.length % 4) {
                base64 += '=';
            }
            return base64;
        }

        function base64ToArrayBuffer(base64) {
            try {
                console.log('🔍 Converting base64 to ArrayBuffer:', base64);
                
                // Check if it's base64url format (contains - or _)
                if (base64.includes('-') || base64.includes('_')) {
                    console.log('🔍 Detected base64url format, converting...');
                    base64 = base64urlToBase64(base64);
                    console.log('🔍 Converted to base64:', base64);
                }
                
                const binaryString = atob(base64);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (error) {
                console.error('❌ Error converting base64 to ArrayBuffer:', error);
                console.error('❌ Input base64 string:', base64);
                throw new Error(`Invalid base64 string: ${error.message}`);
            }
        }

        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }

        function base64ToBase64Url(base64) {
            return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }

        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const accessToken = urlParams.get('access_token');
        const tokenType = urlParams.get('token_type');
        const expiresIn = urlParams.get('expires_in');
        const scope = urlParams.get('scope');
        const authType = urlParams.get('auth_type');
        const code = urlParams.get('code');

        // Handle different authentication types
        if (authType === 'native' && code) {
            // Update success message for Biometric Authentication
            document.getElementById('success-title').textContent = '🎉 Biometric Authentication Successful!';
            document.getElementById('success-description').textContent = 'You have successfully authenticated using biometric authentication with fingerprint or face recognition.';
            
            // Show success alert for Biometric Authentication
            setTimeout(() => {
                alert('🎉 Biometric Authentication Successful!\n\nYou have successfully authenticated using biometric authentication with fingerprint or face recognition.');
            }, 500);
        } else if (authType === 'password') {
            // Update success message for Password Authentication
            document.getElementById('success-title').textContent = '🎉 Password Login Successful!';
            document.getElementById('success-description').textContent = 'You have successfully authenticated using your password credentials.';
        }

        // Decode and display user information from JWT
        if (accessToken) {
            try {
                const tokenParts = accessToken.split('.');
                if (tokenParts.length === 3) {
                    const payload = JSON.parse(atob(tokenParts[1]));
                    
                    // Display user info
                    document.getElementById('user-info').style.display = 'block';
                    document.getElementById('username').textContent = payload.sub || 'Unknown';
                    document.getElementById('org-name').textContent = payload.org_name || 'Unknown';
                }
            } catch (error) {
                console.error('Error decoding JWT:', error);
            }
        }


        
        // Initialize FIDO section
        function initializeFidoSection() {
            const fidoSection = document.getElementById('fido-section');
            const deregisterBtn = document.getElementById('fido-deregister-btn');
            const registerBtn = document.getElementById('fido-register-btn');
            
            // Show FIDO section
            fidoSection.style.display = 'block';
            
            // Get current username from URL parameters or localStorage scan
            let currentUsername = 'admin'; // fallback
            
            // First, try to get username from URL parameters (from login)
            const urlParams = new URLSearchParams(window.location.search);
            const authType = urlParams.get('auth_type');
            console.log('🔍 Auth type from URL:', authType);
            
            // If it's a password login, try to extract userId from access token
            if (authType === 'password') {
                try {
                    const accessToken = localStorage.getItem('accessToken');
                    if (accessToken) {
                        const payload = accessToken.split('.')[1];
                        const decodedPayload = JSON.parse(atob(payload));
                        console.log('🔍 Access Token payload for userId extraction:', decodedPayload);
                        
                        // Extract userId from access token
                        const userId = decodedPayload.sub || decodedPayload.user_id || decodedPayload.userId;
                        if (userId) {
                            currentUsername = userId;
                            console.log('🔍 Using userId from Access Token:', userId);
                        } else {
                            console.warn('No userId found in access token, using fallback');
                        }
                    }
                } catch (e) {
                    console.warn('Could not decode userId from Access Token:', e);
                }
            }
            
            // If no username found from JWT, scan localStorage for any username-based credentials
            if (currentUsername === 'admin') {
                console.log('🔍 No username from JWT, scanning localStorage for username-based credentials...');
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('registeredCredentialId_') && !key.includes('-')) {
                        // Found a username-based credential (not UUID)
                        const username = key.replace('registeredCredentialId_', '');
                        console.log(`🔍 Found username-based credential: ${key}`);
                        currentUsername = username;
                        break;
                    }
                }
            }
            
            console.log('🔍 Final username for credential lookup:', currentUsername);
            
            // Log userId from access token for credential mapping
            try {
                const accessToken = localStorage.getItem('accessToken');
                if (accessToken) {
                    const payload = accessToken.split('.')[1];
                    const decodedPayload = JSON.parse(atob(payload));
                    console.log('🔍 Access Token payload on success page:', decodedPayload);
                    
                    // Check single credentialId
                    console.log('🔍 Checking for single credentialId in localStorage...');
                    const credentialId = localStorage.getItem('credentialId');
                    console.log('🔍 Single credentialId:', credentialId);
                } else {
                    console.warn('No access token found in localStorage on success page');
                }
            } catch (e) {
                console.warn('Could not decode userId from access token on success page:', e);
            }
            
            // Check if credential is already registered (single credentialId)
            const storedCredentialId = localStorage.getItem('credentialId');
            console.log(`🔍 Checking single credentialId: ${storedCredentialId}`);
            
            if (storedCredentialId) {
                // Show deregister button and biometric auth button, hide register button
                deregisterBtn.style.display = 'inline-block';
                document.getElementById('biometric-auth-btn').style.display = 'inline-block';
                registerBtn.style.display = 'none';
                console.log('🔍 Showing deregister button and biometric auth button, hiding register button');
            } else {
                // Show register button, hide deregister button and biometric auth button
                registerBtn.style.display = 'inline-block';
                deregisterBtn.style.display = 'none';
                document.getElementById('biometric-auth-btn').style.display = 'none';
                console.log('🔍 Showing register button, hiding deregister button and biometric auth button');
            }
        }

        // Biometric Authentication function - copied from app.js
        window.startBiometricAuth = async function() {
            try {
                // Clear any existing WebAuthn session before starting new authentication
                console.log('🔍 Clearing WebAuthn session before starting Biometric Authentication...');
                if (navigator.credentials && navigator.credentials.preventSilentAccess) {
                    navigator.credentials.preventSilentAccess();
                    console.log('🔍 Cleared WebAuthn silent access');
                }
                
                // Clear any WebAuthn session storage
                if (sessionStorage) {
                    sessionStorage.clear();
                    console.log('🔍 Cleared session storage');
                }
                
                showMessage('fido-status-message', 'Starting biometric authentication...', 'info');

                // Step 1: Initialize biometric authentication flow
                showMessage('fido-status-message', 'Initializing authentication flow...', 'info');
                const initResponse = await makeRequest('/native-auth/init', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        clientId: WSO2_CLIENT_ID,
                        redirectUri: window.location.origin + '/oauth2/code/wso2',
                        scope: 'openid profile',
                        responseType: 'code',
                        responseMode: 'direct'
                    })
                });

                if (!initResponse.success) {
                    throw new Error(initResponse.message || 'Failed to initialize biometric authentication flow');
                }

                console.log('🔍 Biometric authentication flow initialized');
                showMessage('fido-status-message', 'Authentication flow initialized', 'success');

                // Step 2: Use challenge data directly from init response
                const challengeData = initResponse.data;
                console.log('🔍 Full init response (challenge data):', initResponse);
                console.log('🔍 Challenge data:', challengeData);
                console.log('🔍 Flow ID:', challengeData.flowId);
                console.log('🔍 Next step:', challengeData.nextStep);
                console.log('🔍 Authenticators:', challengeData.nextStep?.authenticators);
                
                // Check if this is challenge data (has nextStep with authenticators)
                if (challengeData.nextStep && challengeData.nextStep.authenticators) {
                    console.log('🔍 Challenge data received, proceeding with WebAuthn...');
                    showMessage('fido-status-message', 'Challenge received, proceeding with biometric authentication...', 'info');
                    
                    // Find biometric authenticator
                    const biometricOption = challengeData.nextStep.authenticators.find(auth => 
                        auth.authenticator === 'Passkey' || 
                        auth.authenticatorId === 'RklET0F1dGhlbnRpY2F0b3I6TE9DQUw' ||
                        auth.authenticatorId === 'FIDOAuthenticator:LOCAL' ||
                        auth.authenticatorId === 'FIDOAuthenticator'
                    );
                    
                    if (biometricOption) {
                        console.log('🔍 Biometric option found:', biometricOption);
                        await performWebAuthnNativeAuth(challengeData, challengeData.flowId, biometricOption.authenticatorId);
                    } else {
                        console.log('🔍 No biometric option found in challenge data');
                        console.log('🔍 Available authenticators:', challengeData.nextStep.authenticators);
                        throw new Error('Biometric option not available in challenge data');
                    }
                } else {
                    // Fallback: if init response doesn't contain challenge data, try old logic
                    console.log('🔍 No challenge data in init response, falling back to old logic...');
                    console.log('🔍 Next step:', challengeData.nextStep);
                    console.log('🔍 Step type:', challengeData.nextStep?.stepType);
                    console.log('🔍 Authenticators:', challengeData.nextStep?.authenticators);
                    
                    let biometricOption = null;
                    if (challengeData.nextStep && challengeData.nextStep.authenticators) {
                        biometricOption = challengeData.nextStep.authenticators.find(auth => 
                            auth.authenticator === 'Passkey' || 
                            auth.authenticatorId === 'RklET0F1dGhlbnRpY2F0b3I6TE9DQUw' ||
                            auth.authenticatorId === 'FIDOAuthenticator:LOCAL' ||
                            auth.authenticatorId === 'FIDOAuthenticator'
                        );
                    }

                    if (biometricOption) {
                        console.log('🔍 Biometric option found, getting challenge...');
                        showMessage('fido-status-message', 'Biometric option found, getting challenge...', 'info');
                        await getPasskeyChallenge(challengeData.flowId, biometricOption.authenticatorId);
                    } else {
                        console.log('🔍 No biometric option found in authenticators');
                        console.log('🔍 Available authenticators:', challengeData.nextStep?.authenticators);
                        
                        // Check if there are any authenticators at all
                        if (!challengeData.nextStep || !challengeData.nextStep.authenticators || challengeData.nextStep.authenticators.length === 0) {
                            console.log('🔍 No authenticators available, creating mock authenticator for WebAuthn...');
                            
                            // Create a mock authenticator to allow WebAuthn to proceed
                            const mockAuthenticator = {
                                authenticatorId: 'MANUAL_FIDO',
                                authenticator: 'Manual FIDO',
                                metadata: {
                                    additionalData: {
                                        challengeData: btoa(JSON.stringify({
                                            publicKeyCredentialRequestOptions: {
                                                challenge: 'mock-challenge',
                                                allowCredentials: [{
                                                    id: 'mock-credential-id',
                                                    type: 'public-key'
                                                }]
                                            },
                                            requestId: 'manual-request-id'
                                        }))
                                    }
                                }
                            };
                            
                            console.log('🔍 Created mock authenticator for WebAuthn');
                            showMessage('fido-status-message', 'Proceeding with WebAuthn authentication...', 'info');
                            await getPasskeyChallenge(challengeData.flowId, mockAuthenticator.authenticatorId);
                        } else {
                            throw new Error('Biometric option not available');
                        }
                    }
                }

            } catch (error) {
                console.error('Biometric authentication failed:', error);
                showMessage('fido-status-message', `Biometric authentication failed: ${error.message}`, 'error');
            }
        }
        
        // Get passkey challenge - copied from app.js
        async function getPasskeyChallenge(flowId, authenticatorId) {
            try {
                // Check if this is a manual FIDO request
                if (authenticatorId === 'MANUAL_FIDO') {
                    console.log('🔍 Manual FIDO request detected, skipping challenge call');
                    showMessage('fido-status-message', 'Using manual credential ID, performing WebAuthn authentication...', 'info');
                    
                    // Create mock challenge data for manual FIDO
                    const mockChallengeData = {
                        nextStep: {
                            authenticators: [{
                                authenticatorId: 'MANUAL_FIDO',
                                metadata: {
                                    additionalData: {
                                        challengeData: btoa(JSON.stringify({
                                            publicKeyCredentialRequestOptions: {
                                                challenge: 'mock-challenge',
                                                allowCredentials: [{
                                                    id: 'manual-credential-id',
                                                    type: 'public-key'
                                                }]
                                            },
                                            requestId: 'manual-request-id'
                                        }))
                                    }
                                }
                            }]
                        }
                    };
                    
                    // Step 3: Perform WebAuthn authentication with mock data
                    await performWebAuthnNativeAuth(mockChallengeData, flowId, authenticatorId);
                } else {
                    const challengeResponse = await makeRequest('/native-auth/challenge', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            flowId: flowId,
                            authenticatorId: authenticatorId
                        })
                    });

                    if (!challengeResponse.success) {
                        throw new Error(challengeResponse.message || 'Failed to get passkey challenge');
                    }

                    showMessage('fido-status-message', 'Challenge received, performing WebAuthn authentication...', 'info');

                    // Step 3: Perform WebAuthn authentication
                    await performWebAuthnNativeAuth(challengeResponse.data, flowId, authenticatorId);
                }

            } catch (error) {
                console.error('Error getting passkey challenge:', error);
                showMessage('fido-status-message', `Failed to get challenge: ${error.message}`, 'error');
            }
        }
        
        // Perform WebAuthn native authentication - copied from app.js
        async function performWebAuthnNativeAuth(challengeData, flowId, authenticatorId) {
            try {
                // Clear any existing WebAuthn session before starting new authentication
                console.log('🔍 Clearing WebAuthn session before authentication...');
                if (navigator.credentials && navigator.credentials.preventSilentAccess) {
                    navigator.credentials.preventSilentAccess();
                    console.log('🔍 Cleared WebAuthn silent access');
                }
                
                // Clear any WebAuthn session storage
                if (sessionStorage) {
                    sessionStorage.clear();
                    console.log('🔍 Cleared session storage');
                }
                
                // Extract challenge data from the response
                let challengeOptions;
                let requestId;
                let credentialId = null; // Initialize to null to avoid undefined errors
                if (challengeData.nextStep && challengeData.nextStep.authenticators && challengeData.nextStep.authenticators[0]) {
                    const authenticator = challengeData.nextStep.authenticators[0];
                    if (authenticator.metadata && authenticator.metadata.additionalData && authenticator.metadata.additionalData.challengeData) {
                        // Decode the base64 challenge data
                        const decodedChallenge = atob(authenticator.metadata.additionalData.challengeData);
                        console.log('🔍 Decoded challenge data:', decodedChallenge);
                        challengeOptions = JSON.parse(decodedChallenge);
                        requestId = challengeOptions.requestId;
                        
                        // Get single credential ID
                        credentialId = localStorage.getItem('credentialId');
                        console.log(`🔍 Looking for single credential ID:`, credentialId);
                        
                        // If no credential found, show popup
                        if (!credentialId) {
                            console.log('🔍 No credential found in localStorage, showing popup...');
                            const userCredentialId = prompt('No credential ID found in localStorage. Please enter your credential ID:');
                            if (!userCredentialId || userCredentialId.trim() === '') {
                                throw new Error('Credential ID is required for authentication.');
                            }
                            credentialId = userCredentialId.trim();
                            console.log('🔍 Using manually entered credential ID:', credentialId);
                        }
                        
                        console.log('🔍 Final credential ID for authentication:', credentialId);
                    }
                }
                
                if (!challengeOptions) {
                    throw new Error('No challenge data found in response');
                }

                // Convert challenge data to WebAuthn format
                let publicKeyCredentialRequestOptions;
                
                if (authenticatorId === 'MANUAL_FIDO') {
                    // For manual FIDO, check localStorage for credentialId first
                    console.log('🔍 Creating challenge data for manual FIDO WebAuthn...');
                    const mockChallenge = 'mock-challenge-for-webauthn';
                    
                    // Check localStorage for single credentialId
                    const storedCredentialId = localStorage.getItem('credentialId');
                    let realCredentialId;
                    
                    if (storedCredentialId) {
                        realCredentialId = storedCredentialId;
                        console.log('🔍 Using stored credentialId from localStorage:', realCredentialId);
                    } else {
                        console.log('🔍 No credentialId found in localStorage, showing popup...');
                        const userCredentialId = prompt('No credential ID found in localStorage. Please enter your credential ID for WebAuthn authentication:');
                        if (!userCredentialId || userCredentialId.trim() === '') {
                            throw new Error('Credential ID is required for WebAuthn authentication.');
                        }
                        realCredentialId = userCredentialId.trim();
                        console.log('🔍 Using manually entered credential ID for WebAuthn:', realCredentialId);
                    }
                    
                    // Validate credentialId format
                    if (!realCredentialId || realCredentialId.length < 10) {
                        throw new Error('Invalid credential ID format. Please ensure you have registered a passkey first.');
                    }
                    
                    // Try to convert to ArrayBuffer to validate format
                    const testArrayBuffer = base64ToArrayBuffer(realCredentialId);
                    console.log('🔍 Credential ID format is valid');
                    
                    publicKeyCredentialRequestOptions = {
                        challenge: base64ToArrayBuffer(btoa(mockChallenge)),
                        allowCredentials: [{
                            id: testArrayBuffer,
                            type: 'public-key',
                            transports: ['internal']
                        }],
                        timeout: 60000,
                        rpId: 'localhost',
                        userVerification: 'required'
                    };
                    
                    console.log('🔍 Created manual FIDO WebAuthn options with credentialId:', realCredentialId);
                } else {
                    // For normal FIDO, use real challenge data
                    publicKeyCredentialRequestOptions = {
                        challenge: base64ToArrayBuffer(challengeOptions.publicKeyCredentialRequestOptions.challenge),
                        allowCredentials: challengeOptions.publicKeyCredentialRequestOptions.allowCredentials ? 
                            challengeOptions.publicKeyCredentialRequestOptions.allowCredentials.map(cred => ({
                                id: base64ToArrayBuffer(cred.id),
                                type: cred.type,
                                transports: cred.transports
                            })) : [],
                        timeout: 60000,
                        rpId: 'localhost',
                        userVerification: 'required'
                    };
                    
                    // Update allowCredentials with the found credentialId
                    if (credentialId) {
                        publicKeyCredentialRequestOptions.allowCredentials = [{
                            id: base64ToArrayBuffer(credentialId),
                            type: 'public-key',
                            transports: ['internal', 'hybrid']
                        }];
                        console.log('🔍 Updated allowCredentials with credentialId:', credentialId);
                    }
                }
                
                console.log('🔍 Final WebAuthn options:', publicKeyCredentialRequestOptions);
                console.log('🔍 Challenge type:', typeof publicKeyCredentialRequestOptions.challenge);
                console.log('🔍 Challenge value:', publicKeyCredentialRequestOptions.challenge);
                console.log('🔍 AllowCredentials:', publicKeyCredentialRequestOptions.allowCredentials);
                
                // Perform WebAuthn authentication
                showMessage('fido-status-message', 'Please scan your biometric (fingerprint/face)...', 'info');
                
                const credential = await navigator.credentials.get({
                    publicKey: publicKeyCredentialRequestOptions
                });
                
                if (!credential) {
                    throw new Error('WebAuthn authentication was cancelled or failed');
                }
                
                console.log('🔍 WebAuthn credential received:', credential);
                
                console.log('🔍 WebAuthn authentication successful');
                showMessage('fido-status-message', 'WebAuthn authentication successful, verifying...', 'info');
                
                // Prepare credentials for verification
                const credentials = {
                    clientDataJSON: arrayBufferToBase64url(credential.response.clientDataJSON),
                    authenticatorData: arrayBufferToBase64url(credential.response.authenticatorData),
                    signature: arrayBufferToBase64url(credential.response.signature),
                    userHandle: credential.response.userHandle ? arrayBufferToBase64url(credential.response.userHandle) : null,
                    credentialId: arrayBufferToBase64url(credential.rawId)
                };
                
                // Verify biometric authentication
                await verifyPasskeyAuth(credentials, flowId, authenticatorId, requestId);
                
            } catch (error) {
                console.error('WebAuthn native authentication failed:', error);
                console.error('Error name:', error.name);
                console.error('Error message:', error.message);
                
                // Check if it's a WebAuthn specific error
                if (error.name === 'NotAllowedError') {
                    showMessage('fido-status-message', 'Biometric authentication was cancelled by user', 'warning');
                } else if (error.name === 'NotSupportedError') {
                    showMessage('fido-status-message', 'Biometric authentication is not supported on this device', 'error');
                } else if (error.name === 'SecurityError') {
                    showMessage('fido-status-message', 'Security error during biometric authentication', 'error');
                } else if (error.message.includes('challenge')) {
                    showMessage('fido-status-message', 'Invalid challenge format. Please try again.', 'error');
                } else {
                    showMessage('fido-status-message', `Biometric authentication failed: ${error.message}`, 'error');
                }
            }
        }
        
        
        // Verify passkey authentication - copied from app.js
        async function verifyPasskeyAuth(credentials, flowId, authenticatorId, requestId) {
            try {
                console.log('🔍 VERIFY PASSKEY AUTH - Starting...');
                
                // Check localStorage for single credentialId first
                console.log('🔍 Checking localStorage for single credentialId...');
                const storedCredentialId = localStorage.getItem('credentialId');
                let credentialId;
                
                if (storedCredentialId) {
                    credentialId = storedCredentialId;
                    console.log('🔍 Using stored credentialId from localStorage:', credentialId);
                } else {
                    console.log('🔍 No credentialId found in localStorage, showing popup...');
                    const userCredentialId = prompt('No credential ID found in localStorage. Please enter your credential ID for authentication:');
                    if (!userCredentialId || userCredentialId.trim() === '') {
                        throw new Error('Credential ID is required for authentication.');
                    }
                    credentialId = userCredentialId.trim();
                    console.log('🔍 Using manually entered credentialId:', credentialId);
                }
                
                // Update credentials with the manually entered credentialId
                credentials.credentialId = credentialId;
                
                console.log('🔍 Sending requestId to backend:', requestId);
                console.log('🔍 Credentials object:', credentials);
                console.log('🔍 CredentialId in credentials:', credentials.credentialId);
                
                const requestBody = {
                    flowId: flowId,
                    authenticatorId: authenticatorId,
                    credentials: credentials,
                    requestId: requestId
                };
                
                console.log('🔍 Full request body:', requestBody);
                console.log('🔍 About to make API call to: /native-auth/verify');
                
                const verifyResponse = await makeRequest('/native-auth/verify', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestBody)
                });

                console.log('🔍 Raw verify response:', verifyResponse);
                console.log('🔍 HTTP 200 response received - treating as success!');
                console.log('✅ SUCCESS FLOW - No errors, proceeding to success page');
                console.log('🔍 SERVER RESPONSE SUCCESS - This is a valid success from server');
                
                // Store credential ID for success page (if available)
                if (credentialId && credentialId !== '') {
                    localStorage.setItem('lastUsedCredentialId', credentialId);
                    console.log('🔍 Stored credentialId in localStorage');
                } else {
                    console.log('🔍 No credentialId to store (using empty string)');
                }
                
                showMessage('fido-status-message', '🎉 Biometric authentication successful!', 'success');
                
                // Show success alert
                setTimeout(() => {
                    alert('🎉 Biometric Authentication Successful!\n\nYou have successfully authenticated using biometric authentication with fingerprint or face recognition.');
                }, 500);
                
            } catch (error) {
                console.error('❌ ERROR CAUGHT - Analyzing error type:');
                console.error('🔍 Error type:', typeof error);
                console.error('🔍 Error message:', error.message);
                console.error('🔍 Error stack:', error.stack);
                console.error('🔍 Full error object:', error);
                
                // Check if this is a server error (HTTP error) or client logic error
                const isServerError = error.message && error.message.includes('HTTP error');
                const isCredentialIdError = error.message && error.message.includes('credentialId');
                
                console.log('🔍 Is server error:', isServerError);
                console.log('🔍 Is credentialId error:', isCredentialIdError);
                
                if (isServerError) {
                    console.error('🔍 SERVER ERROR - This is a valid server error, should show error message');
                    showMessage('fido-status-message', `Server error: ${error.message}`, 'error');
                } else if (isCredentialIdError) {
                    console.error('🔍 CLIENT LOGIC ERROR - This is a client logic error, should NOT show error message');
                    showMessage('fido-status-message', 'Client logic error, please try again', 'warning');
                } else {
                    console.error('🔍 UNKNOWN ERROR TYPE:', error.message);
                    showMessage('fido-status-message', `Verification failed: ${error.message}`, 'error');
                }
            }
        }
        
        // Helper function to convert ArrayBuffer to base64url
        function arrayBufferToBase64url(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
        }
        
        // Helper function to convert base64url to ArrayBuffer
        function base64urlToArrayBuffer(base64url) {
            const base64 = base64url.replace(/-/g, '+').replace(/_/g, '/');
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) {
                bytes[i] = binary.charCodeAt(i);
            }
            return bytes.buffer;
        }
        
        // Helper function to convert base64 to ArrayBuffer - copied from app.js
        function base64ToArrayBuffer(base64) {
            // Convert base64url to base64
            const base64Standard = base64.replace(/-/g, '+').replace(/_/g, '/');
            
            // Add padding if needed
            const padded = base64Standard + '='.repeat((4 - base64Standard.length % 4) % 4);
            
            try {
                const binaryString = atob(padded);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    bytes[i] = binaryString.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (error) {
                console.error('Error converting base64 to ArrayBuffer:', error);
                console.error('Original base64:', base64);
                console.error('Standardized base64:', padded);
                throw error;
            }
        }

        // Logout function
        window.logoutSuccess = function() {
            console.log('🔍 Logout: Starting logout process...');
            
            // Clear stored tokens
            localStorage.removeItem('accessToken');
            localStorage.removeItem('tokenType');
            localStorage.removeItem('expiresIn');
            localStorage.removeItem('scope');
            localStorage.removeItem('refreshToken');
            localStorage.removeItem('idToken');
            localStorage.removeItem('lastUsedCredentialId');
            
            // Keep credentialId for Biometric Authentication
            console.log('🔍 Logout: Keeping credentialId for Biometric Authentication:', localStorage.getItem('credentialId'));
            
            // Clear any WebAuthn session data
            if (navigator.credentials && navigator.credentials.preventSilentAccess) {
                navigator.credentials.preventSilentAccess();
                console.log('🔍 Logout: Cleared WebAuthn silent access');
            }
            
            // Clear any WebAuthn session storage
            if (sessionStorage) {
                sessionStorage.clear();
                console.log('🔍 Logout: Cleared session storage');
            }
            
            console.log('🔍 Logout: Cleared authentication tokens, keeping credentialId');
            
            // Redirect to login page
            window.location.href = '/';
        }

        
        // Initialize FIDO section when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeFidoSection();
        });
    </script>

    <style>
        .success-card {
            max-width: 800px;
            margin: 0 auto;
        }
        
        .success-message {
            text-align: center;
            margin-bottom: 2rem;
            padding: 2rem;
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border-radius: 10px;
            border: 1px solid #c3e6cb;
        }
        
        .success-message h3 {
            color: #155724;
            margin: 1rem 0;
        }
        
        .text-success {
            color: #28a745 !important;
        }
        
        .user-info {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .user-field {
            margin: 1rem 0;
            display: flex;
            align-items: center;
        }
        
        .user-field label {
            font-weight: bold;
            min-width: 120px;
            margin-right: 1rem;
        }
        
        .user-value {
            font-family: 'Courier New', monospace;
            background: #fff;
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid #ced4da;
            flex: 1;
        }
        
        
        .action-buttons {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-top: 2rem;
            flex-wrap: wrap;
        }
        
        
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        
        .fido-section {
            margin: 2rem 0;
            padding: 1.5rem;
            background: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #dee2e6;
        }
        
        .fido-info p {
            margin-bottom: 1rem;
            color: #6c757d;
        }
        
        .button-group {
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .status-message {
            margin-top: 1rem;
            padding: 0.75rem;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .status-message.success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-message.error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .status-message.info {
            background: #d1ecf1;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        
        @media (max-width: 768px) {
            .user-field {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .user-field label {
                margin-bottom: 0.5rem;
            }
            
            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</body>
</html> 